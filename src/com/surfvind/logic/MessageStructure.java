package com.surfvind.logic;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

/**
 * Message structure
 * 
 * Contains a complete message structure. The point of this class is not to
 * contruct one yourself but to decode files or strings. Hence the constructor
 * is private
 * 
 * @author Erik
 */
public class MessageStructure {

	public String phoneNo;
	public int smsClass;
	public String smsPid;
	public boolean bit7;
	public String message;

	private MessageStructure(String phoNo, int smsClass, String smsPid,
			boolean bit7, String message) {
		this.phoneNo = phoNo;
		this.smsClass = smsClass;
		this.smsPid = smsPid;
		this.bit7 = bit7;
		this.message = message;
	}

	/**
	 * Encodes the settings to a string.
	 * 
	 * @param phoNo
	 * @param smsClass
	 * @param smsPid
	 * @param bit7
	 * @param pduMode
	 * @param modemCommands
	 * @param message
	 * @return
	 */
	public static String encodeToString(String phoNo, int smsClass,
			String smsPid, boolean bit7, String message) {

		String encodedMessage = new String();
		encodedMessage += "AUTOGENERATED: Modifications might cause unexpected behaviour.\n";
		encodedMessage += "Structure:\nPhone number\nsmsClass\nsmsPid\n7bit\npduMode\nmodemCommands\nmessage\n";
		encodedMessage += "START\n";
		encodedMessage += phoNo + "\n";
		encodedMessage += smsClass + "\n";
		encodedMessage += smsPid + "\n";
		encodedMessage += bit7 + "\n";
		encodedMessage += "MESSAGE_START\n";
		encodedMessage += message + "\n";
		encodedMessage += "MESSAGE_END\n";
		encodedMessage += "END_OF_FILE";

		return encodedMessage;
	}

	/**
	 * TODO: Need to set some limits, so that this method does not get stuck in case
	 * of a bad message.
	 * 
	 * Decode a message string
	 * 
	 * @param s
	 * @returns a MessageStructure. There are no getters, access the elements
	 *          directly
	 */
	public static MessageStructure decodeString(String s) {
		String phoNo;
		int smsClass;
		String smsPid;
		boolean bit7;
		String message;

		int line;
		line = 0;
		/* Find the start line */
		while (!readLine(s, line++).equals("START")) {
			;
		}

		phoNo = readLine(s, line++);
		smsClass = Integer.valueOf(readLine(s, line++));
		smsPid = readLine(s, line++);
		bit7 = Boolean.valueOf(readLine(s, line++));
		
		while(!readLine(s, line++).equals("MESSAGE_START")) {
			;
		}
		
		message = "";
		while(!readLine(s, line).equals("MESSAGE_END")) {
			message += readLine(s, line++);
			message += "\n";
		}

		/* Simple check to see of everything is in order */
		if (readLine(s, ++line).equals("END_OF_FILE")) {
			return new MessageStructure(phoNo, smsClass, smsPid, bit7,message);
		} else {
			System.err.println("ERROR PARSING MESSAGE!");
			return null;
		}
	}

	/**
	 * @param s
	 *            the string to parse
	 * @param line
	 *            the line of interest
	 * @returns the complete line
	 */
	private static String readLine(String s, int line) {
		int nbrOfLinesFound, position;
		String retLine;
		char next;

		nbrOfLinesFound = 0;
		position = 0;
		while (position < s.length() - 1 && nbrOfLinesFound < line) {
			if (s.charAt(position++) == '\n') {
				nbrOfLinesFound++;
			}
		}

		retLine = "";
		while (position < s.length() && (next = s.charAt(position++)) != '\n') {
			retLine += next;
		}
		return retLine;
	}

	/**
	 * Decodes a file
	 * 
	 * @param file
	 *            the file to parse
	 * @returns a message structure if the file was parsed. Null if any problems
	 *          occurred
	 */
	public static MessageStructure decodeFile(File file) {
		if (file == null) {
			return null;
		}
		String s, nextLine;
		FileReader fr;
		BufferedReader br;

		s = "";
		try {
			fr = new FileReader(file);
			br = new BufferedReader(fr);

			while ((nextLine = br.readLine()) != null) {
				s += nextLine + '\n';
			}
		} catch (IOException ioe) {
			return null;
		}

		return decodeString(s);
	}
}
